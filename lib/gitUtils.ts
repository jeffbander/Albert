/**
 * Git utilities for auto-committing and pushing project changes
 * Windows-compatible: Uses exec() instead of bash
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as os from 'os';
import * as path from 'path';

const execAsync = promisify(exec);

export interface CommitResult {
  success: boolean;
  sha?: string;
  error?: string;
  pushed?: boolean;
}

/**
 * Initialize a git repository in the workspace
 */
export async function initGitRepo(workspacePath: string): Promise<{ success: boolean; error?: string }> {
  try {
    await execAsync('git init', { cwd: workspacePath });
    return { success: true };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Git init failed'
    };
  }
}

/**
 * Auto-commit changes in a project workspace
 * Windows-compatible: Uses temp file for commit message
 */
export async function autoCommitProject(
  workspacePath: string,
  projectDescription: string,
  options: {
    push?: boolean;
    remote?: string;
    branch?: string;
  } = {}
): Promise<CommitResult> {
  // Default to push = true per user request
  const { push = true, remote = 'origin', branch = 'main' } = options;

  // First, ensure git is initialized
  await initGitRepo(workspacePath);

  const shortDescription = projectDescription.slice(0, 50) + (projectDescription.length > 50 ? '...' : '');

  const commitMessage = `ðŸš€ Build: ${shortDescription}

Built autonomously by Albert using Claude Code.

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>`;

  // Write commit message to temp file (avoids shell escaping issues on all platforms)
  const msgFile = path.join(os.tmpdir(), `albert-commit-msg-${Date.now()}.txt`);

  try {
    await fs.writeFile(msgFile, commitMessage, 'utf-8');

    // Stage all changes
    await execAsync('git add -A', { cwd: workspacePath });

    // Check if there are changes to commit
    const { stdout: statusOutput } = await execAsync('git status --porcelain', { cwd: workspacePath });

    if (!statusOutput.trim()) {
      return {
        success: true,
        error: 'Nothing to commit - no changes detected',
      };
    }

    // Commit using file for message (works on Windows and Unix)
    const { stdout } = await execAsync(`git commit -F "${msgFile}"`, { cwd: workspacePath });

    // Extract commit SHA from output
    const shaMatch = stdout.match(/\[[\w-]+\s+([a-f0-9]+)\]/);
    const sha = shaMatch ? shaMatch[1] : undefined;

    // Auto-push if enabled (DEFAULT: true)
    let pushed = false;
    if (push) {
      try {
        await execAsync(`git push ${remote} ${branch}`, { cwd: workspacePath });
        pushed = true;
      } catch (pushError) {
        // Push failed but commit succeeded - still a partial success
        console.error('[GitUtils] Push failed:', pushError);
      }
    }

    return {
      success: true,
      sha,
      pushed,
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Git commit failed';

    // Check if it's just "nothing to commit"
    if (errorMessage.includes('nothing to commit')) {
      return {
        success: true,
        error: 'Nothing to commit - no changes detected',
      };
    }

    return {
      success: false,
      error: errorMessage,
    };
  } finally {
    // Cleanup temp file
    await fs.unlink(msgFile).catch(() => {});
  }
}

/**
 * Auto-commit self-improvement changes
 * Windows-compatible: Uses temp file for commit message
 */
export async function autoCommitSelfImprovement(
  task: string,
  push: boolean = true
): Promise<CommitResult> {
  const cwd = process.cwd();

  const commitMessage = `ðŸ¤– Self-improvement: ${task.slice(0, 50)}${task.length > 50 ? '...' : ''}

Generated by Albert's self-improvement system using Claude Code.

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>`;

  // Write commit message to temp file
  const msgFile = path.join(os.tmpdir(), `albert-self-improve-${Date.now()}.txt`);

  try {
    await fs.writeFile(msgFile, commitMessage, 'utf-8');

    // Stage all changes
    await execAsync('git add -A', { cwd });

    // Check if there are changes to commit
    const { stdout: statusOutput } = await execAsync('git status --porcelain', { cwd });

    if (!statusOutput.trim()) {
      return {
        success: true,
        error: 'Nothing to commit - no changes detected',
      };
    }

    // Commit using file for message
    const { stdout } = await execAsync(`git commit -F "${msgFile}"`, { cwd });

    // Extract commit SHA
    const shaMatch = stdout.match(/\[[\w-]+\s+([a-f0-9]+)\]/);
    const sha = shaMatch ? shaMatch[1] : undefined;

    // Auto-push if enabled (DEFAULT: true)
    let pushed = false;
    if (push) {
      try {
        await execAsync('git push', { cwd });
        pushed = true;
      } catch (pushError) {
        console.error('[GitUtils] Self-improvement push failed:', pushError);
      }
    }

    return {
      success: true,
      sha,
      pushed,
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Git commit failed';

    if (errorMessage.includes('nothing to commit')) {
      return {
        success: true,
        error: 'Nothing to commit - no changes detected',
      };
    }

    return {
      success: false,
      error: errorMessage,
    };
  } finally {
    await fs.unlink(msgFile).catch(() => {});
  }
}

/**
 * Push changes to a remote GitHub repository
 * Windows-compatible: Uses exec() instead of bash
 */
export async function pushToGitHub(
  workspacePath: string,
  repoName: string,
  options: {
    owner?: string;
    branch?: string;
    createRepo?: boolean;
  } = {}
): Promise<{ success: boolean; repoUrl?: string; error?: string }> {
  const { owner, branch = 'main', createRepo = true } = options;

  try {
    // If createRepo is true, try to create the repo first using gh CLI
    if (createRepo) {
      try {
        const { stdout } = await execAsync(
          `gh repo create ${repoName} --public --source . --push`,
          { cwd: workspacePath }
        );

        // Extract repo URL from output
        const urlMatch = stdout.match(/https:\/\/github\.com\/[\w-]+\/[\w-]+/);
        return {
          success: true,
          repoUrl: urlMatch ? urlMatch[0] : `https://github.com/${owner || 'user'}/${repoName}`,
        };
      } catch {
        // If repo creation fails (maybe it exists), try to add remote and push
        const remoteUrl = owner
          ? `https://github.com/${owner}/${repoName}.git`
          : `https://github.com/${repoName}.git`;

        try {
          // Try to add remote (ignore error if it exists)
          await execAsync(`git remote add origin ${remoteUrl}`, { cwd: workspacePath }).catch(() => {});

          // Set remote URL in case it exists with different URL
          await execAsync(`git remote set-url origin ${remoteUrl}`, { cwd: workspacePath });

          // Push with upstream tracking
          await execAsync(`git push -u origin ${branch}`, { cwd: workspacePath });

          return {
            success: true,
            repoUrl: remoteUrl.replace('.git', ''),
          };
        } catch (pushError) {
          return {
            success: false,
            error: pushError instanceof Error ? pushError.message : 'Failed to push to GitHub',
          };
        }
      }
    } else {
      // Just push to existing remote
      await execAsync(`git push -u origin ${branch}`, { cwd: workspacePath });
      return {
        success: true,
        repoUrl: `https://github.com/${owner || 'user'}/${repoName}`,
      };
    }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to push to GitHub',
    };
  }
}

/**
 * Get the current git status of a workspace
 */
export async function getGitStatus(workspacePath: string): Promise<{
  hasChanges: boolean;
  branch?: string;
  ahead?: number;
  behind?: number;
}> {
  try {
    const { stdout } = await execAsync('git status --porcelain -b', { cwd: workspacePath });
    const lines = stdout.trim().split('\n');
    const branchLine = lines[0] || '';
    const branchMatch = branchLine.match(/^## (\S+)/);
    const aheadMatch = branchLine.match(/ahead (\d+)/);
    const behindMatch = branchLine.match(/behind (\d+)/);

    return {
      hasChanges: lines.length > 1,
      branch: branchMatch ? branchMatch[1] : undefined,
      ahead: aheadMatch ? parseInt(aheadMatch[1]) : 0,
      behind: behindMatch ? parseInt(behindMatch[1]) : 0,
    };
  } catch {
    return { hasChanges: false };
  }
}

/**
 * Get current commit SHA
 */
export async function getCurrentCommitSha(workspacePath: string = process.cwd()): Promise<string | undefined> {
  try {
    const { stdout } = await execAsync('git rev-parse --short HEAD', { cwd: workspacePath });
    return stdout.trim();
  } catch {
    return undefined;
  }
}

/**
 * Check if workspace has uncommitted changes
 */
export async function hasUncommittedChanges(workspacePath: string = process.cwd()): Promise<boolean> {
  try {
    const { stdout } = await execAsync('git status --porcelain', { cwd: workspacePath });
    return stdout.trim().length > 0;
  } catch {
    return false;
  }
}
